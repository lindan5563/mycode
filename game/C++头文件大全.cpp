#include<bits/stdc++.h>
using namespace std;
int main()
{
/*c++头文件: 

#include <bits/stdc++.h>   //万能头文件，包含说有头文件，在某些c++ 中不可使用 

#include <algorithm>　　　 //STL通用算法

#include <bitset>　　　　　//STL位集容器

#include <complex>　　　　 //复数类

#include <deque>　　　　　 //STL双端队列容器

#include <exception>　　　 //异常处理类

#include <functional>　　　//STL定义运算函数（代替运算符）

#include <list>　　　　　　//STL线性列表容器

#include <map>　　　　　　 //STL 映射容器

#include <ios>　　　　　　 //基本输入／输出支持

#include <iosfwd>　　　　　//输入／输出系统使用的前置声明

#include <istream>　　　　 //基本输入流

#include <ostream>　　　　 //基本输出流

#include <queue>　　　　　 //STL队列容器

#include <set>　　　　　　 //STL 集合容器

#include <sstream>　　　　 //基于字符串的流

#include <stack>　　　　　 //STL堆栈容器　　　
　
#include <stdexcept>　　　 //标准异常类

#include <streambuf>　　　 //底层输入／输出支持

#include <string>　　　　　//字符串类

#include <utility>　　　　 //STL通用模板类

#include <vector>　　　　　//STL动态数组容器

#include <assert.h>　　　　//设定插入点

#include <ctype.h>　　　　 //字符处理

#include <errno.h>　　　　 //定义错误码

#include <float.h>　　　　 //浮点数处理

#include <fstream.h>　　　 //文件输入／输出

#include <iomanip.h>　　　 //参数化输入／输出

#include <iostream.h>　　　//数据流输入／输出

#include <limits.h>　　　　//定义各种数据类型最值常量

#include <locale.h>　　　　//定义本地化函数

#include <math.h>　　　　　//定义数学函数

#include <stdio.h>　　　　 //定义输入／输出函数

#include <stdlib.h>　　　　//定义杂项函数及内存分配函数

#include <string.h>　　　　//字符串处理

#include <strstrea.h>　　　//基于数组的输入／输出

#include <time.h>　　　　　//定义关于时间的函数

#include <wchar.h>　　　　 //宽字符处理及输入／输出

#include <wctype.h>　　　　//宽字符分类

函数: 

分类函数,所在函数库为ctype.h

int isalpha(int ch) 若ch是字母('A'-'Z','a'-'z')返回非0值,否则返回0

int isalnum(int ch) 若ch是字母('A'-'Z','a'-'z')或数字('0'-'9') 返回非0值,否则返回0

int isascii(int ch) 若ch是字符(ASCII码中的0-127)返回非0值,否则返回0

int iscntrl(int ch) 若ch是作废字符(0x7F)或普通控制字符(0x00-0x1F) 返回非0值,否则返回0

int isdigit(int ch) 若ch是数字('0'-'9')返回非0值,否则返回0

int isgraph(int ch) 若ch是可打印字符(不含空格)(0x21-0x7E)返回非0值,否则返回0

int islower(int ch) 若ch是小写字母('a'-'z')返回非0值,否则返回0

int isprint(int ch) 若ch是可打印字符(含空格)(0x20-0x7E)返回非0值,否则返回0

int ispunct(int ch) 若ch是标点字符(0x00-0x1F)返回非0值,否则返回0

int isspace(int ch)  若ch是空格(''),水平制表符('\t'),回车符('\r'), 走纸换行('\f'),垂直制表符('\v'),换行符('\n')返回非0值,否则返回0

int isupper(int ch) 若ch是大写字母('A'-'Z')返回非0值,否则返回0

int isxdigit(int ch)若ch是16进制数('0'-'9','A'-'F','a'-'f')返回非0值, 否则返回0

int tolower(int ch) 若ch是大写字母('A'-'Z')返回相应的小写字母('a'-'z')

int toupper(int ch) 若ch是小写字母('a'-'z')返回相应的大写字母('A'-'Z')

数学函数,所在函数库为math.h、stdlib.h、string.h、float.h

int     abs(inti)                   返回整型参数i的绝对值

double  cabs(struct complexznum)     返回复数znum的绝对值

double  fabs(doublex)                返回双精度参数x的绝对值

long   labs(longn)                  返回长整型参数n的绝对值

double   exp(doublex)                返回指数函数ex的值

double frexp(double value,int*eptr)  返回value=x*2n中x的值,n存贮在eptr中

double ldexp(double value,intexp);   返回value*2exp的值

double   log(doublex)                返回logex的值

double log10(doublex)                返回log10x的值

double   pow(double x,doubley)       返回xy的值

double pow10(intp)                   返回10p的值

double  sqrt(doublex)                返回+√x的值

double  acos(doublex)                返回x的反余弦cos-1(x)值,x为弧度

double  asin(doublex)                返回x的反正弦sin-1(x)值,x为弧度

double  atan(doublex)                返回x的反正切tan-1(x)值,x为弧度

double atan2(double y,doublex)       返回y/x的反正切tan-1(x)值,y的x为弧度

double   cos(doublex)                返回x的余弦cos(x)值,x为弧度

double   sin(doublex)                返回x的正弦sin(x)值,x为弧度

double   tan(doublex)                返回x的正切tan(x)值,x为弧度

double  cosh(doublex)                返回x的双曲余弦cosh(x)值,x为弧度

double  sinh(doublex)                返回x的双曲正弦sinh(x)值,x为弧度

double  tanh(doublex)                返回x的双曲正切tanh(x)值,x为弧度

double hypot(double x,doubley)       返回直角三角形斜边的长度(z), x和y为直角边的长度,z2=x2+y2

double  ceil(doublex)                返回不小于x的最小整数

double floor(doublex)                返回不大于x的最大整数

void   srand(unsignedseed)           初始化随机数发生器

int    rand()                        产生一个随机数并返回这个数

double  poly(double x,int n,double c[])从参数产生一个多项式

double  modf(double value,double *iptr)将双精度数value分解成尾数和阶

double  fmod(double x,doubley)       返回x/y的余数

double frexp(double value,int*eptr)   将双精度数value分成尾数和阶

double  atof(char*nptr)              将字符串nptr转换成浮点数并返回这个浮点数

double  atoi(char*nptr)              将字符串nptr转换成整数并返回这个整数

double  atol(char*nptr)              将字符串nptr转换成长整数并返回这个整数

char   *ecvt(double value,intndigit,int *decpt,int *sign) 将浮点数value转换成字符串并返回该字符串

char   *fcvt(double value,intndigit,int *decpt,int *sign) 将浮点数value转换成字符串并返回该字符串

char   *gcvt(double value,intndigit,char *buf) 将数value转换成字符串并存于buf中,并返回buf的指针

char  *ultoa(unsigned long value,char*string,int radix) 将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数

char   *ltoa(long value,char*string,int radix) 将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数

char   *itoa(int value,char*string,int radix) 将整数value转换成字符串存入string,radix为转换时所用基数

double atof(char *nptr) 将字符串nptr转换成双精度数,并返回这个数,错误返回0

int   atoi(char *nptr) 将字符串nptr转换成整型数,  并返回这个数,错误返回0

long   atol(char *nptr)将字符串nptr转换成长整型数,并返回这个数,错误返回0

double strtod(char *str,char **endptr)将字符串str转换成双精度数,并返回这个数,

long   strtol(char *str,char**endptr,int base)将字符串str转换成长整型数, 并返回这个数,

int         matherr(struct exception *e) 用户修改数学错误返回信息函数(没有必要使用)

double      _matherr(_mexcep why,char *fun,double*arg1p, double *arg2p,double retval)用户修改数学错误返回信息函数(没有必要使用)

unsigned int _clear87()  清除浮点状态字并返回原来的浮点状态

void        _fpreset()   重新初使化浮点数学程序包

unsigned int _status87()  返回浮点状态字

目录函数,所在函数库为dir.h、dos.h

int    chdir(char *path)使指定的目录path（如:"C:\\WPS"）变成当前的工作目录,成 功返回0

int findfirst(char *pathname,struct ffblk *ffblk,intattrib)查找指定的文件,成功返回0

　　　　pathname为指定的目录名和文件名,如"C:\\WPS\\TXT"

    　　　　ffblk为指定的保存文件信息的一个结构,定义如下:

   ┏━━━━━━━━━━━━━━━━━━┓

    ┃structffblk                       ┃

   ┃{                                  ┃

    ┃ charff_reserved[21]; ┃

    ┃ charff_attrib;      ┃

    ┃int ff_ftime;       ┃

    ┃int ff_fdate;       ┃

    ┃ longff_fsize;       ┃

    ┃ charff_name[13];       ┃

   ┃}                                  ┃

   ┗━━━━━━━━━━━━━━━━━━┛

    attrib为文件属性,由以下字符代表

   ┏━━━━━━━━━┳━━━━━━━━┓

   ┃FA_RDONLY 只读文件┃FA_LABEL  卷标号┃

   ┃FA_HIDDEN 隐藏文件┃FA_DIREC  目录 ┃

   ┃FA_SYSTEM 系统文件┃FA_ARCH  档案  ┃

   ┗━━━━━━━━━┻━━━━━━━━┛

    例:

    structffblk ff;

   findfirst("*.wps",&ff,FA_RDONLY);

 

int   findnext(struct ffblk*ffblk)     取匹配finddirst的文件,成功返回0

void  fumerge(char *path,char *drive,char*dir,char *name,char *ext)

      此函数通过盘符drive(C:、A:等),路径dir(\TC、\BC\LIB等),

      文件名name(TC、WPS等),扩展名ext(.EXE、.COM等)组成一个文件名

      存与path中.

int   fnsplit(char *path,char*drive,char *dir,char *name,char *ext)

      此函数将文件名path分解成盘符drive(C:、A:等),路径dir(\TC、\BC\LIB等),

      文件名name(TC、WPS等),扩展名ext(.EXE、.COM等),并分别存入相应的变量中.

int   getcurdir(int drive,char*direc) 此函数返回指定驱动器的当前工作目录名称

       drive 指定的驱动器(0=当前,1=A,2=B,3=C等)

       direc保存指定驱动器当前工作路径的变量     成功返回0

char *getcwd(char *buf,iint n) 此函数取当前工作目录并存入buf中,直到n个字

     节长为为止.错误返回NULL

int   getdisk()取当前正在使用的驱动器,返回一个整数(0=A,1=B,2=C等)

int   setdisk(int drive)设置要使用的驱动器drive(0=A,1=B,2=C等),

      返回可使用驱动器总数

int   mkdir(char*pathname)  建立一个新的目录pathname,成功返回0

int   rmdir(char*pathname)  删除一个目录pathname,成功返回0

char *mktemp(char *template) 构造一个当前目录上没有的文件名并存于template中

char *searchpath(char *pathname) 利用MSDOS找出文件filename所在路径,

     ,此函数使用DOS的PATH变量,未找到文件返回NULL

进程函数,所在函数库为stdlib.h、process.h

void  abort()此函数通过调用具有出口代码3的_exit写一个终止信息于stderr，

       并异常终止程序。无返回值

int   exec…装入和运行其它程序

int   execl( char *pathname,char *arg0,char *arg1,…,char *argn,NULL)

int   execle( char*pathname,char *arg0,char *arg1,…,char *argn,NULL,char *envp[])

int   execlp( char*pathname,char *arg0,char *arg1,…,NULL)

int   execlpe(char*pathname,char *arg0,char *arg1,…,NULL,char *envp[])

int   execv( char *pathname,char *argv[])

int   execve( char*pathname,char *argv[],char *envp[])

int   execvp( char*pathname,char *argv[])

int   execvpe(char*pathname,char *argv[],char *envp[])

        exec函数族装入并运行程序pathname，并将参数

         arg0(arg1,arg2,argv[],envp[])传递给子程序,出错返回-1

      在exec函数族中,后缀l、v、p、e添加到exec后，

      所指定的函数将具有某种操作能力

     有后缀  p时，函数可以利用DOS的PATH变量查找子程序文件。

             l时，函数中被传递的参数个数固定。

             v时，函数中被传递的参数个数不固定。

             e时，函数传递指定参数envp，允许改变子进程的环境，

                  无后缀e时，子进程使用当前程序的环境。

 

void  _exit(int status)终止当前程序,但不清理现场

void  exit(int status)终止当前程序,关闭所有文件,写缓冲区的输出(等待输出),

                      并调用任何寄存器的"出口函数",无返回值

 

int   spawn…运行子程序

int  spawnl(  int mode,char *pathname,char *arg0,char*arg1,…,char *argn,NULL)

int   spawnle( int mode,char*pathname,char *arg0,char *arg1,…, char*argn,NULL,char *envp[])

int   spawnlp( int mode,char*pathname,char *arg0,char *arg1,…, char*argn,NULL)

int   spawnlpe(int mode,char*pathname,char *arg0,char *arg1,…, char*argn,NULL,char *envp[])

int  spawnv(  int mode,char *pathname,char *argv[])

int   spawnve( int mode,char*pathname,char *argv[],char *envp[])

int   spawnvp( int mode,char*pathname,char *argv[])

int   spawnvpe(int mode,char*pathname,char *argv[],char *envp[])

      spawn函数族在mode模式下运行子程序pathname,并将参数

       arg0(arg1,arg2,argv[],envp[])传递给子程序.出错返回-1

      mode为运行模式

       mode为 P_WAIT  表示在子程序运行完后返回本程序

              P_NOWAIT 表示在子程序运行时同时运行本程序(不可用)

              P_OVERLAY表示在本程序退出后运行子程序

       在spawn函数族中,后缀l、v、p、e添加到spawn后，

       所指定的函数将具有某种操作能力

       有后缀 p时, 函数利用DOS的PATH查找子程序文件

              l时, 函数传递的参数个数固定.

              v时, 函数传递的参数个数不固定.

              e时, 指定参数envp可以传递给子程序,允许改变子程序运行环境.

                 当无后缀e时,子程序使用本程序的环境.

 

int   system(char *command)将MSDOS命令command传递给DOS执行

转换子程序,函数库为math.h、stdlib.h、ctype.h、float.h

char   *ecvt(double value,intndigit,int *decpt,int *sign)

        将浮点数value转换成字符串并返回该字符串

char   *fcvt(double value,intndigit,int *decpt,int *sign)

        将浮点数value转换成字符串并返回该字符串

char   *gcvt(double value,intndigit,char *buf)

        将数value转换成字符串并存于buf中,并返回buf的指针

char  *ultoa(unsigned long value,char*string,int radix)

        将无符号整型数value转换成字符串并返回该字符串,radix为转换时所用基数

char   *ltoa(long value,char*string,int radix)

        将长整型数value转换成字符串并返回该字符串,radix为转换时所用基数

char   *itoa(int value,char*string,int radix)

        将整数value转换成字符串存入string,radix为转换时所用基数

double atof(char *nptr) 将字符串nptr转换成双精度数,并返回这个数,错误返回0

int   atoi(char *nptr) 将字符串nptr转换成整型数,  并返回这个数,错误返回0

long   atol(char *nptr)将字符串nptr转换成长整型数,并返回这个数,错误返回0

double strtod(char *str,char **endptr)将字符串str转换成双精度数,并返回这个数,

long   strtol(char *str,char**endptr,int base)将字符串str转换成长整型数,

                                              并返回这个数,

int   toascii(int c)   返回c相应的ASCII

int   tolower(int ch) 若ch是大写字母('A'-'Z')返回相应的小写字母('a'-'z')

int   _tolower(intch)  返回ch相应的小写字母('a'-'z')

int   toupper(int ch) 若ch是小写字母('a'-'z')返回相应的大写字母('A'-'Z')

int   _toupper(intch)  返回ch相应的大写字母('A'-'Z')

诊断函数,所在函数库为assert.h、math.h

void   assert(int test)一个扩展成if语句那样的宏，如果test测试失败，

       就显示一个信息并异常终止程序,无返回值

void   perror(char *string)本函数将显示最近一次的错误信息，格式如下：

       字符串string:错误信息

char   *strerror(char *str)本函数返回最近一次的错误信息,格式如下:

       字符串str:错误信息

int   matherr(struct exception *e)

       用户修改数学错误返回信息函数(没有必要使用)

double _matherr(_mexcep why,char *fun,double *arg1p,

               double *arg2p,double retval)

       用户修改数学错误返回信息函数(没有必要使用)

 

输入输出子程序,函数库为io.h、conio.h、stat.h、dos.h、stdio.h、signal.h

int  kbhit()   本函数返回最近所敲的按键

int   fgetchar()从控制台(键盘)读一个字符，显示在屏幕上

int  getch()   从控制台(键盘)读一个字符，不显示在屏幕上

int  putch()   向控制台(键盘)写一个字符

int  getchar()  从控制台(键盘)读一个字符，显示在屏幕上

int  putchar()  向控制台(键盘)写一个字符

int  getche()  从控制台(键盘)读一个字符，显示在屏幕上

int   ungetch(int c)把字符c退回给控制台(键盘)

char *cgets(char *string) 从控制台(键盘)读入字符串存于string中

int   scanf(char*format[,argument…])从控制台读入一个字符串,分别对各个参数进行

      赋值,使用BIOS进行输出

int   vscanf(char*format,Valist param)从控制台读入一个字符串,分别对各个参数进行

      赋值,使用BIOS进行输出,参数从Valist param中取得

int   cscanf(char*format[,argument…])从控制台读入一个字符串,分别对各个参数进行

      赋值,直接对控制台作操作,比如显示器在显示时字符时即为直接写频方式显示

int   sscanf(char *string,char*format[,argument,…])通过字符串string,分别对各个

      参数进行赋值

int   vsscanf(char*string,char *format,Vlist param)通过字符串string,分别对各个

      参数进行赋值,参数从Vlist param中取得

int   puts(char*string)  发关一个字符串string给控制台(显示器),

      使用BIOS进行输出

void  cputs(char *string)发送一个字符串string给控制台(显示器),

      直接对控制台作操作,比如显示器即为直接写频方式显示

int   printf(char*format[,argument,…]) 发送格式化字符串输出给控制台(显示器)

      使用BIOS进行输出

int   vprintf(char*format,Valist param) 发送格式化字符串输出给控制台(显示器)

      使用BIOS进行输出,参数从Valist param中取得

int   cprintf(char*format[,argument,…]) 发送格式化字符串输出给控制台(显示器),

      直接对控制台作操作,比如显示器即为直接写频方式显示

int   vcprintf(char*format,Valist param)发送格式化字符串输出给控制台(显示器),

      直接对控制台作操作,比如显示器即为直接写频方式显示,

      参数从Valist param中取得

int   sprintf(char*string,char *format[,argument,…])

       将字符串string的内容重新写为格式化后的字符串

int   vsprintf(char*string,char *format,Valist param)

       将字符串string的内容重新写为格式化后的字符串,参数从Valist param中取得

int   rename(char*oldname,char *newname)将文件oldname的名称改为newname

int   ioctl(int handle,intcmd[,int *argdx,int argcx])

       本函数是用来控制输入/输出设备的，请见下表：

       ┌───┬────────────────────────────┐

       │cmd值│功能                                                   │

       ├───┼────────────────────────────┤

       │  0  │取出设备信息                                           │

       │  1  │设置设备信息                                           │

       │  2  │把argcx字节读入由argdx所指的地址                       │

       │  3  │在argdx所指的地址写argcx字节                           │

       │  4  │除把handle当作设备号(0=当前,1=A,等)之外,均和cmd=2时一样 │

       │  5  │除把handle当作设备号(0=当前,1=A,等)之外,均和cmd=3时一样 │

       │  6  │取输入状态                                             │

       │  7  │取输出状态                                             │

       │  8  │测试可换性;只对于DOS3.x                               │

       │  11  │置分享冲突的重算计数;只对DOS3.x                       │

       └───┴────────────────────────────┘

int   (*ssignal(intsig,int(*action)())()执行软件信号(没必要使用)

int   gsignal(intsig)                  执行软件信号(没必要使用)

 

int   _open(char *pathname,intaccess)为读或写打开一个文件,

       按后按access来确定是读文件还是写文件,access值见下表

       ┌──────┬────────────────────┐

       │access值   │意义                                   │

       ├──────┼────────────────────┤

       │O_RDONLY   │读文件                                 │

       │O_WRONLY   │写文件                                 │

       │O_RDWR     │即读也写                               │

       │O_NOINHERIT│若文件没有传递给子程序,则被包含        │

       │O_DENYALL  │只允许当前处理必须存取的文件           │

       │O_DENYWRITE│只允许从任何其它打开的文件读           │

       │O_DENYREAD │只允许从任何其它打开的文件写           │

       │O_DENYNONE │允许其它共享打开的文件                 │

       └──────┴────────────────────┘

int   open(char *pathname,intaccess[,int permiss])为读或写打开一个文件,

       按后按access来确定是读文件还是写文件,access值见下表

       ┌────┬────────────────────┐

       │access值│意义                                   │

       ├────┼────────────────────┤

       │O_RDONLY│读文件                                 │

       │O_WRONLY│写文件                                 │

       │O_RDWR │即读也写                               │

       │O_NDELAY│没有使用;对UNIX系统兼容                │

       │O_APPEND│即读也写,但每次写总是在文件尾添加      │

       │O_CREAT │若文件存在,此标志无用;若不存在,建新文件 │

       │O_TRUNC│若文件存在,则长度被截为0,属性不变      │

       │O_EXCL │未用;对UNIX系统兼容                    │

       │O_BINARY│此标志可显示地给出以二进制方式打开文件  │

       │O_TEXT  │此标志可用于显示地给出以文本方式打开文件│

       └────┴────────────────────┘

       permiss为文件属性,可为以下值:

        S_IWRITE允许写  S_IREAD允许读 S_IREAD|S_IWRITE允许读、写

int   creat(char *filename,intpermiss)  建立一个新文件filename，并设定

      读写性。permiss为文件读写性，可以为以下值

       S_IWRITE允许写  S_IREAD允许读 S_IREAD|S_IWRITE允许读、写

int  _creat(char *filename,intattrib)  建立一个新文件filename，并设定文件

     属性。attrib为文件属性，可以为以下值

       FA_RDONLY只读  FA_HIDDEN隐藏 FA_SYSTEM系统

int   creatnew(char*filenamt,int attrib) 建立一个新文件filename，并设定文件

      属性。attrib为文件属性，可以为以下值

        FA_RDONLY只读  FA_HIDDEN隐藏 FA_SYSTEM系统

int   creattemp(char*filenamt,int attrib) 建立一个新文件filename，并设定文件

      属性。attrib为文件属性，可以为以下值

        FA_RDONLY只读  FA_HIDDEN隐藏 FA_SYSTEM系统

int   read(int handle,void*buf,int nbyte)从文件号为handle的文件中读nbyte个字符

      存入buf中

int  _read(int handle,void *buf,intnbyte)从文件号为handle的文件中读nbyte个字符

      存入buf中,直接调用MSDOS进行操作.

int   write(int handle,void*buf,int nbyte)将buf中的nbyte个字符写入文件号

      为handle的文件中

int  _write(int handle,void *buf,intnbyte)将buf中的nbyte个字符写入文件号

      为handle的文件中

int   dup(int handle)复制一个文件处理指针handle,返回这个指针

int   dup2(int handle,intnewhandle) 复制一个文件处理指针handle到newhandle

int   eof(int*handle)检查文件是否结束,结束返回1,否则返回0

long  filelength(int handle)返回文件长度，handle为文件号

int   setmode(inthandle,unsigned mode)本函数用来设定文件号为handle的文件的打

      开方式

int   getftime(inthandle,struct ftime *ftime) 读取文件号为handle的文件的时间，

       并将文件时间存于ftime结构中，成功返回0,ftime结构如下：

       ┌─────────────────┐

       │structftime                     │

       │{                                │

       │ unsigned ft_tsec:5;      │

       │ unsigned ft_min:6;       │

       │ unsigned ft_hour:5;      │

       │ unsigned ft_day:5;       │

       │ unsignedft_month:4;      │

       │ unsigned ft_year:1;   │

       │}                                │

       └─────────────────┘

int   setftime(inthandle,struct ftime *ftime) 重写文件号为handle的文件时间,

      新时间在结构ftime中.成功返回0.结构ftime如下:

       ┌─────────────────┐

       │structftime                     │

       │{                                │

       │ unsigned ft_tsec:5;      │

       │ unsigned ft_min:6;       │

       │ unsigned ft_hour:5;      │

       │ unsigned ft_day:5;       │

       │ unsignedft_month:4;      │

       │ unsigned ft_year:1;   │

       │}                                │

       └─────────────────┘

long  lseek(int handle,long offset,intfromwhere) 本函数将文件号为handle的文件

       的指针移到fromwhere后的第offset个字节处.

        SEEK_SET 文件开关   SEEK_CUR当前位置   SEEK_END 文件尾

long  tell(int handle)本函数返回文件号为handle的文件指针,以字节表示

int   isatty(inthandle)本函数用来取设备handle的类型

int   lock(int handle,longoffset,long length)  对文件共享作封锁

int   unlock(int handle,longoffset,long length) 打开对文件共享的封锁

int   close(int handle)关闭handle所表示的文件处理,handle是从_creat、creat、

       creatnew、creattemp、dup、dup2、_open、open中的一个处调用获得的文件处理

       成功返回0否则返回-1,可用于UNIX系统

int  _close(int handle)关闭handle所表示的文件处理,handle是从_creat、creat、

      creatnew、creattemp、dup、dup2、_open、open中的一个处调用获得的文件处理

      成功返回0否则返回-1,只能用于MSDOS系统

 

FILE *fopen(char *filename,char *type)打开一个文件filename,打开方式为type，

       并返回这个文件指针，type可为以下字符串加上后缀

     ┌──┬────┬───────┬────────┐

     │type│读写性  │文本/2进制文件│建新/打开旧文件 │

     ├──┼────┼───────┼────────┤

     │r  │读     │文本         │打开旧的文件    │

     │w  │写     │文本         │建新文件       │

     │a  │添加   │文本         │有就打开无则建新│

     │r+  │读/写  │不限制       │打开           │

     │w+  │读/写  │不限制       │建新文件       │

     │a+  │读/添加│不限制       │有就打开无则建新│

     └──┴────┴───────┴────────┘

     可加的后缀为t、b。加b表示文件以二进制形式进行操作，t没必要使用

     例: ┌──────────────────┐

         │#include<stdio.h>                  │

         │main()                             │

         │{                                  │

         │ FILE*fp;                         │

         │ fp=fopen("C:\\WPS\\WPS.EXE","r+b");│

         └──────────────────┘

FILE *fdopen(int ahndle,char *type)

FILE *freopen(char *filename,char *type,FILE *stream)

int   getc(FILE*stream)  从流stream中读一个字符，并返回这个字符

int   putc(int ch,FILE*stream)向流stream写入一个字符ch

int   getw(FILE *stream)从流stream读入一个整数，错误返回EOF

int   putw(int w,FILE*stream)向流stream写入一个整数

int   ungetc(char c,FILE*stream) 把字符c退回给流stream，下一次读进的字符将是c

int   fgetc(FILE *stream)从流stream处读一个字符，并返回这个字符

int   fputc(int ch,FILE*stream) 将字符ch写入流stream中

char *fgets(char *string,int n,FILE *stream)从流stream中读n个字符存入string中

int   fputs(char *string,FILE*stream) 将字符串string写入流stream中

int   fread(void *ptr,intsize,int nitems,FILE *stream) 从流stream中读入nitems

      个长度为size的字符串存入ptr中

int   fwrite(void *ptr,intsize,int nitems,FILE *stream) 向流stream中写入nitems

      个长度为size的字符串,字符串在ptr中

int   fscanf(FILE *stream,char*format[,argument,…]) 以格式化形式从流stream中

      读入一个字符串

int   vfscanf(FILE*stream,char *format,Valist param) 以格式化形式从流stream中

      读入一个字符串,参数从Valist param中取得

int   fprintf(FILE*stream,char *format[,argument,…]) 以格式化形式将一个字符

      串写给指定的流stream

int   vfprintf(FILE*stream,char *format,Valist param) 以格式化形式将一个字符

      串写给指定的流stream,参数从Valist param中取得

int   fseek(FILE *stream,longoffset,int fromwhere) 函数把文件指针移到fromwhere

      所指位置的向后offset个字节处,fromwhere可以为以下值:

      SEEK_SET 文件开关   SEEK_CUR当前位置   SEEK_END 文件尾

long  ftell(FILE *stream) 函数返回定位在stream中的当前文件指针位置,以字节表示

int   rewind(FILE *stream)将当前文件指针stream移到文件开头

int   feof(FILE *stream)检测流stream上的文件指针是否在结束位置

int   fileno(FILE *stream)取流stream上的文件处理，并返回文件处理

int   ferror(FILE *stream)检测流stream上是否有读写错误，如有错误就返回1

void  clearerr(FILE *stream)清除流stream上的读写错误

void  setbuf(FILE *stream,char *buf)给流stream指定一个缓冲区buf

void  setvbuf(FILE *stream,char *buf,inttype,unsigned size)

      给流stream指定一个缓冲区buf,大小为size,类型为type,type的值见下表

     ┌───┬───────────────────────────────┐

     │type值│意义                                                         │

     ├───┼───────────────────────────────┤

     │_IOFBF│文件是完全缓冲区,当缓冲区是空时,下一个输入操作将企图填满整个缓│

     │     │冲区.在输出时,在把任何数据写到文件之前,将完全填充缓冲区.     │

     │_IOLBF│文件是行缓冲区.当缓冲区为空时,下一个输入操作将仍然企图填整个缓│

     │     │冲区.然而在输出时,每当新行符写到文件,缓冲区就被清洗掉.       │

     │_IONBF│文件是无缓冲的.buf和size参数是被忽略的.每个输入操作将直接从文 │

     │     │件读,每个输出操作将立即把数据写到文件中.                     │

     └───┴───────────────────────────────┘

int   fclose(FILE *stream)关闭一个流，可以是文件或设备(例如LPT1)

int  fcloseall()         关闭所有除stdin或stdout外的流

int   fflush(FILE *stream)关闭一个流，并对缓冲区作处理

       处理即对读的流，将流内内容读入缓冲区；

       对写的流，将缓冲区内内容写入流。成功返回0

int  fflushall()         关闭所有流，并对流各自的缓冲区作处理

       处理即对读的流，将流内内容读入缓冲区；

       对写的流，将缓冲区内内容写入流。成功返回0

 

int   access(char*filename,int amode) 本函数检查文件filename并返回文件的属性,

       函数将属性存于amode中，amode由以下位的组合构成

         06可以读、写      04可以读  02可以写  01执行(忽略的)   00文件存在

     如果filename是一个目录,函数将只确定目录是否存在

     函数执行成功返回0,否则返回-1

int   chmod(char *filename,intpermiss) 本函数用于设定文件filename的属性

       permiss可以为以下值

          S_IWRITE允许写  S_IREAD允许读 S_IREAD|S_IWRITE允许读、写

int  _chmod(char *filename,int func[,intattrib]);

      本函数用于读取或设定文件filename的属性，

      当func=0时，函数返回文件的属性；当func=1时，函数设定文件的属性

      若为设定文件属性，attrib可以为下列常数之一

      FA_RDONLY只读  FA_HIDDEN隐藏 FA_SYSTEM系统 

接口子程序,所在函数库为:dos.h、bios.h

unsigned sleep(unsigned seconds)暂停seconds微秒(百分之一秒)

int     unlink(char *filename)删除文件filename

unsigned FP_OFF(void far *farptr)本函数用来取远指针farptr的偏移量

unsigned FP_SEG(void far *farptr)本函数用来没置远指针farptr的段值

void far *MK_FP(unsigned seg,unsignedoff)根据段seg和偏移量off构造一个far指针

unsigned getpsp()取程序段前缀的段地址,并返回这个地址

char *parsfnm(char *cmdline,struct fcb *fcbptr,int option)

      函数分析一个字符串,通常,对一个文件名来说,是由cmdline所指的一个命令行.

      文件名是放入一个FCB中作为一个驱动器,文件名和扩展名.FCB是由fcbptr所指

      定的.option参数是DOS分析系统调用时,AL文本的值.

 

int   absread(int drive,intnsects,int sectno,void *buffer)本函数功能为读特定的

      磁盘扇区,drive为驱动器号(0=A,1=B等),nsects为要读的扇区数,sectno为开始的逻

      辑扇区号,buffer为保存所读数据的保存空间

int   abswrite(int drive,intnsects,int sectno,void *buffer)本函数功能为写特定的

      磁盘扇区,drive为驱动器号(0=A,1=B等),nsects为要写的扇区数,sectno为开始的逻

      辑扇区号,buffer为保存所写数据的所在空间

void  getdfree(int drive,struct dfree*dfreep)本函数用来取磁盘的自由空间,

      drive为磁盘号(0=当前,1=A等).函数将磁盘特性的由dfreep指向的dfree结构中.

      dfree结构如下:

      ┌───────────────────┐

      │structdfree                         │

      │{                                    │

      │ unsigned df_avail;    │

      │ unsigned df_total;    │

      │ unsigned df_bsec;  │

      │ unsigned df_sclus;   │

      │}                                    │

      └───────────────────┘

char far*getdta()            取磁盘转换地址DTA

void     setdta(char far *dta)设置磁盘转换地址DTA

void  getfat(int drive,fatinfo *fatblkp)

      本函数返回指定驱动器drive(0=当前,1=A,2=B等)的文件分配表信息

      并存入结构fatblkp中,结构如下:

      ┌──────────────────┐

      │structfatinfo                     │

      │{                                  │

      │ char fi_sclus;    │

      │ char fi_fatid; │

      │ int  fi_nclus;       │

      │ int  fi_bysec;   │

      │}                                  │

      └──────────────────┘

void  getfatd(struct fatinfo *fatblkp)本函数返回当前驱动器的文件分配表信息,

      并存入结构fatblkp中,结构如下:          

      ┌──────────────────┐

      │structfatinfo                     │

      │{                                  │

      │ char fi_sclus;    │

      │ char fi_fatid; │

      │ int  fi_nclus;       │

      │ int  fi_bysec;   │

      │}                                  │

      └──────────────────┘

 

int   bdos(int dosfun,unsigneddosdx,unsigned dosal)本函数对MSDOS系统进行调用,

      dosdx为寄存器dx的值,dosal为寄存器al的值,dosfun为功能号

int   bdosptr(int dosfun,void*argument,unsiigned dosal)本函数对MSDOS系统进行调用,

      argument为寄存器dx的值,dosal为寄存器al的值,dosfun为功能号

int   int86(int intr_num,unionREGS *inregs,union REGS *outregs)

      执行intr_num号中断,用户定义的寄存器值存于结构inregs中,

      执行完后将返回的寄存器值存于结构outregs中.

int   int86x(intintr_num,union REGS *inregs,union REGS *outregs,

            struct SREGS *segregs)执行intr_num号中断,用户定义的寄存器值存于

      结构inregs中和结构segregs中,执行完后将返回的寄存器值存于结构outregs中.

int   intdos(union REGS*inregs,union REGS *outregs)

      本函数执行DOS中断0x21来调用一个指定的DOS函数,用户定义的寄存器值

      存于结构inregs中,执行完后函数将返回的寄存器值存于结构outregs中

int   intdosx(union REGS*inregs,union REGS *outregs,struct SREGS *segregs)

      本函数执行DOS中断0x21来调用一个指定的DOS函数,用户定义的寄存器值

      存于结构inregs和segregs中,执行完后函数将返回的寄存器值存于结构outregs中

void  intr(int intr_num,struct REGPACK*preg)本函数中一个备用的8086软件中断接口

      它能产生一个由参数intr_num指定的8086软件中断.函数在执行软件中断前,

      从结构preg复制用户定义的各寄存器值到各个寄存器.软件中断完成后,

      函数将当前各个寄存器的值复制到结构preg中.参数如下:

      intr_num 被执行的中断号

      preg为保存用户定义的寄存器值的结构,结构如下

      ┌──────────────────────┐

      │structREGPACK                             │

      │{                                          │

      │ unsignedr_ax,r_bx,r_cx,r_dx;             │

      │ unsigned r_bp,r_si,r_di,r_ds,r_es,r_flags; │

      │}                                          │

      └──────────────────────┘

      函数执行完后,将新的寄存器值存于结构preg中

void  keep(int status,intsize)以status状态返回MSDOS,但程序仍保留于内存中,所占

      用空间由size决定.

void  ctrlbrk(int (*fptr)())设置中断后的对中断的处理程序.

void  disable() 禁止发生中断

void  enable()  允许发生中断

void  geninterrupt(intintr_num)执行由intr_num所指定的软件中断

void  interrupt(* getvect(int intr_num))()返回中断号为intr_num的中断处理程序,

      例如: old_int_10h=getvect(0x10);

void  setvect(int intr_num,void interrupt(*isr)()) 设置中断号为intr_num的中

      断处理程序为isr,例如: setvect(0x10,new_int_10h);

void  harderr(int (*fptr)()) 定义一个硬件错误处理程序,

      每当出现错误时就调用fptr所指的程序

void  hardresume(int rescode)硬件错误处理函数

void  hardretn(int errcode) 硬件错误处理函数

int   inport(int prot)从指定的输入端口读入一个字,并返回这个字

int   inportb(intport)从指定的输入端口读入一个字节,并返回这个字节

void  outport(int port,int word)将字word写入指定的输出端口port

void  outportb(int port,charbyte)将字节byte写入指定的输出端口port

int   peek(intsegment,unsigned offset) 函数返回segment:offset处的一个字

char  peekb(int segment,unsignedoffset)函数返回segment:offset处的一个字节

void  poke(int segment,int offset,char value)将字value写到segment:offset处

void  pokeb(int segment,int offset,int value)将字节value写到segment:offset处

int   randbrd(struct fcb*fcbptr,int reccnt)

      函数利用打开fcbptr所指的FCB读reccnt个记录.

int   randbwr(struct fcb*fcbptr,int reccnt)

      函数将fcbptr所指的FCB中的reccnt个记录写到磁盘上

void  segread(struct SREGS*segtbl)函数把段寄存器的当前值放进结构segtbl中

int  getverify()        取检验标志的当前状态(0=检验关闭,1=检验打开)

void  setverify(int value)设置当前检验状态,

      value为0表示关闭检验,为1表示打开检验

int  getcbrk()本函数返回控制中断检测的当前设置

int   setcbrk(intvalue)本函数用来设置控制中断检测为接通或断开

      当value=0时,为断开检测.当value=1时,为接开检测

 

int   dosexterr(struct DOSERR*eblkp)取扩展错误.在DOS出现错误后,此函数将扩充的

      错误信息填入eblkp所指的DOSERR结构中.该结构定义如下:

     ┌──────────────┐

     │structDOSERR              │

     │{                          │

     │ int  exterror; │

     │ char class;   │

     │ char action;     │

     │ char locus;   │

     │}                          │

     └──────────────┘

int   bioscom(int cmd,chartype,int port) 本函数负责对数据的通讯工作,

       cmd可以为以下值:

       0置通讯参数为字节byte值    1 发送字符通过通讯线输出

       2从通讯线接受字符          3 返回通讯的当前状态

       port为通讯端口,port=0时通讯端口为COM1,port=1时通讯端口为COM2,以此类推

       byte为传送或接收数据时的参数,为以下位的组合:

       ┌───┬─────┬───┬─────┬───┬─────┐

       │byte值│意义     │byte值│意义     │byte值│意义     │               │

       ├───┼─────┼───┼─────┼───┼─────┤

       │0x02  │7数据位  │0x03  │8数据位  │0x00  │1停止位  │               │

       │0x04  │2停止位  │0x00  │无奇偶性 │0x08 │奇数奇偶性│               │

       │0x18  │偶数奇偶性│0x00 │110波特   │0x20 │150波特  │               │

       │0x40  │300波特  │0x60  │600波特  │0x80  │1200波特 │               │

       │0xA0  │2400波特 │0xC0  │4800波特 │0xE0  │9600波特 │               │

       └───┴─────┴───┴─────┴───┴─────┘

       例如:0xE0|0x08|0x00|0x03即表示置通讯口为9600波特,奇数奇偶性,1停止位,

            8数据位.

       函数返回值为一个16位整数,定义如下:

       第15位 超时

       第14位 传送移位寄存器空

       第13位 传送固定寄存器空

       第12位 中断检测

       第11位 帧错误

       第10位 奇偶错误

       第 9位 过载运行错误

       第 8位 数据就绪

       第 7位 接收线信号检测

       第 6位 环形指示器

       第 5位 数据设置就绪

       第 4位 清除发送

       第 3位 δ接收线信号检测器

       第 2位 下降边环形检测器

       第 1位 δ数据设置就绪

       第 0位 δ清除发送

 

int   biosdisk(int cmd,intdrive,int head,int track,

              int sector,int nsects,void *buffer)

      本函数用来对驱动器作一定的操作,cmd为功能号,

      drive为驱动器号(0=A,1=B,0x80=C,0x81=D,0x82=E等).cmd可为以下值:

       0 重置软磁盘系统.这强迫驱动器控制器来执行硬复位.忽略所有其它参数.

       1 返回最后的硬盘操作状态.忽略所有其它参数

       2 读一个或多个磁盘扇区到内存.读开始的扇区由head、track、sector给出。

         扇区号由nsects给出。把每个扇区512个字节的数据读入buffer

       3 从内存读数据写到一个或多个扇区。写开始的扇区由head、track、sector

         给出。扇区号由nsects给出。所写数据在buffer中，每扇区512个字节。

       4 检验一个或多个扇区。开始扇区由head、track、sector给出。扇区号由

         nsects给出。

       5 格式化一个磁道，该磁道由head和track给出。buffer指向写在指定track上

         的扇区磁头器的一个表。

         以下cmd值只允许用于XT或AT微机：

       6 格式化一个磁道，并置坏扇区标志。

       7 格式化指定磁道上的驱动器开头。

       8 返回当前驱动器参数，驱动器信息返回写在buffer中(以四个字节表示)。

       9 初始化一对驱动器特性。

      10 执行一个长的读，每个扇区读512加4个额外字节

      11 执行一个长的写，每个扇区写512加4个额外字节

      12 执行一个磁盘查找

      13 交替磁盘复位

      14 读扇区缓冲区

      15 写扇区缓冲区

      16 检查指定的驱动器是否就绪

      17 复核驱动器

      18 控制器RAM诊断

      19 驱动器诊断

      20 控制器内部诊

      函数返回由下列位组合成的状态字节：

      0x00 操作成功

      0x01 坏的命令

      0x02 地址标记找不到

      0x04 记录找不到

      0x05 重置失败

      0x07 驱动参数活动失败

      0x09 企图DMA经过64K界限

      0x0B 检查坏的磁盘标记

      0x10 坏的ECC在磁盘上读

      0x11 ECC校正的数据错误（注意它不是错误）

      0x20 控制器失效

      0x40 查找失败

      0x80 响应的连接失败

      0xBB 出现无定义错误

      0xFF 读出操作失败

 

int   biodquip()检查设备，函数返回一字节，该字节每一位表示一个信息，如下：

      第15位 打印机号

      第14位 打印机号

      第13位 未使用

      第12位 连接游戏I/O

      第11位 RS232端口号

      第 8位 未使用

      第 7位 软磁盘号

      第 6位 软磁盘号,

             00为1号驱动器,01为2号驱动器,10为3号驱动器,11为4号驱动器

      第 5位 初始化

      第 4位 显示器模式

             00为未使用，01为40x25BW彩色显示卡

             10为80x25BW彩色显示卡，11为80x25BW单色显示卡

      第 3位 母扦件

      第 2位 随机存贮器容量,00为16K,01为32K,10为48K,11为64K

      第 1位 浮点共用处理器

      第 0位 从软磁盘引导

 

int   bioskey(intcmd)本函数用来执行各种键盘操作，由cmd确定操作。

      cmd可为以下值：

      0 返回敲键盘上的下一个键。若低8位为非0,即为ASCII字符；若低8位为0,

        则返回扩充了的键盘代码。

      1 测试键盘是否可用于读。返回0表示没有键可用；否则返回下一次敲键之值。

        敲键本身一直保持由下次调用具的cmd值为0的bioskey所返回的值。

      2 返回当前的键盘状态，由返回整数的每一个位表示，见下表：

       ┌──┬───────────┬───────────┐

       │ 位│为0时意义            │为1时意义            │

       ├──┼───────────┼───────────┤

       │ 7 │插入状态             │改写状态             │

       │ 6 │大写状态             │小写状态             │

       │ 5  │数字状态，NumLock灯亮 │光标状态，NumLock灯熄 │

       │ 4 │ScrollLock灯亮       │ScrollLock灯熄       │

       │ 3 │Alt按下              │Alt未按下            │

       │ 2 │Ctrl按下             │Ctrl未按下           │

       │ 1 │左Shift按下          │左Shift未按下        │

       │ 0 │右Shift按下          │右Shift未按下        │

       └──┴───────────┴───────────┘

int  biosmemory()返回内存大小,以K为单位.

int   biosprint(int cmd,intbyte,int port)控制打印机的输入/输出.

      port为打印机号,0为LPT1,1为LPT2,2为LPT3等

      cmd可以为以下值:

        0 打印字符,将字符byte送到打印机

        1 打印机端口初始化

        2 读打印机状态

      函数返回值由以下位值组成表示当前打印机状态

        0x01 设备时间超时

        0x08 输入/输出错误

        0x10 选择的

        0x20 走纸

        0x40 认可

        0x80 不忙碌

 

int   biostime(int cmd,longnewtime)计时器控制,cmd为功能号,可为以下值

       0 函数返回计时器的当前值

       1 将计时器设为新值newtime

 

struct country *country(int countrycmode,struct country*countryp)

      本函数用来控制某一国家的相关信息,如日期,时间,货币等.

      若countryp=-1时,当前的国家置为countrycode值(必须为非0).否则,由countryp

      所指向的country结构用下列的国家相关信息填充:

      (1)当前的国家(若countrycode为0或2)由countrycode所给定的国家.

      结构country定义如下:

     ┌────────────────────┐

     │structcountry                         │

     │{                                      │

     │ int co_date;            │

     │ charco_curr[5];         │

     │ charco_thsep[2];       │

     │ charco_desep[2];          │

     │ charco_dtsep[2];       │

     │ charco_tmsep[2];       │

     │ charco_currstyle;       │

     │ charco_digits;          │

     │ int (far *co_case)(); │

     │ charco_dasep;          │

     │ charco_fill[10];        │

     │}                                      │

     └────────────────────┘

      co_date的值所代表的日期格式是:

       0 月日年    1日月年    2 年月日

      co_currstrle的值所代表的货币显示方式是

       0 货币符号在数值前,中间无空格

       1 货币符号在数值后,中间无空格

       2 货币符号在数值前,中间有空格

       3 货币符号在数值后,中间有空格

操作函数,所在函数库为string.h、mem.h

mem…操作存贮数组

void *memccpy(void *destin,void *source,unsigned charch,unsigned n)

void *memchr(void *s,char ch,unsigned n)

void *memcmp(void *s1,void *s2,unsigned n)

int   memicmp(void *s1,void*s2,unsigned n)

void *memmove(void *destin,void *source,unsigned n)

void *memcpy(void *destin,void *source,unsigned n)

void *memset(void *s,char ch,unsigned n)

这些函数,mem…系列的所有成员均操作存贮数组.在所有这些函数中,数组是n字节长.

memcpy从source复制一个n字节的块到destin.如果源块和目标块重迭,则选择复制方向,

  以例正确地复制覆盖的字节.

memmove与memcpy相同.

memset将s的所有字节置于字节ch中.s数组的长度由n给出.

memcmp比较正好是n字节长的两个字符串s1和s2.些函数按无符号字符比较字节,因此,

  memcmp("0xFF","\x7F",1)返回值大于0.

memicmp比较s1和s2的前n个字节,不管字符大写或小写.

memccpy从source复制字节到destin.复制一结束就发生下列任一情况:

  (1)字符ch首选复制到destin.

  (2)n个字节已复制到destin.

memchr对字符ch检索s数组的前n个字节.

返回值:memmove和memcpy返回destin

      memset返回s的值

      memcmp和memicmp─┬─若s1<s2返回值小于0

                       ├─若s1=s2返回值等于0

                       └─若s1>s2返回值大于0

      memccpy若复制了ch,则返回直接跟随ch的在destin中的字节的一个指针;

             否则返回NULL

      memchr返回在s中首先出现ch的一个指针;如果在s数组中不出现ch,就返回NULL.

 

void  movedata(int segsrc,int offsrc,

              int segdest,int offdest,

              unsigned numbytes)

      本函数将源地址(segsrc:offsrc)处的numbytes个字节

      复制到目标地址(segdest:offdest)

void  movemem(void *source,void*destin,unsigned len)

      本函数从source处复制一块长len字节的数据到destin.若源地址和目标地址字符串

      重迭,则选择复制方向,以便正确的复制数据.

void  setmem(void *addr,int len,char value)

      本函数把addr所指的块的第一个字节置于字节value中.

 

str…字符串操作函数

char   stpcpy(char *dest,constchar *src)

       将字符串src复制到dest

char   strcat(char *dest,constchar *src)

       将字符串src添加到dest末尾

char   strchr(const char*s,int c)

       检索并返回字符c在字符串s中第一次出现的位置

int   strcmp(const char *s1,const char *s2)

       比较字符串s1与s2的大小,并返回s1-s2

char   strcpy(char *dest,constchar *src)

       将字符串src复制到dest

size_t strcspn(const char *s1,const char *s2)

       扫描s1,返回在s1中有,在s2中也有的字符个数

char   strdup(const char*s)

       将字符串s复制到最近建立的单元

int   stricmp(const char *s1,const char *s2)

       比较字符串s1和s2,并返回s1-s2

size_t strlen(const char *s)

       返回字符串s的长度

char   strlwr(char *s)

       将字符串s中的大写字母全部转换成小写字母,并返回转换后的字符串

char   strncat(char*dest,const char *src,size_t maxlen)

       将字符串src中最多maxlen个字符复制到字符串dest中

int   strncmp(const char *s1,const char *s2,size_t maxlen)

       比较字符串s1与s2中的前maxlen个字符

char   strncpy(char*dest,const char *src,size_t maxlen)

       复制src中的前maxlen个字符到dest中

int   strnicmp(const char *s1,const char *s2,size_t maxlen)

       比较字符串s1与s2中的前maxlen个字符

char   strnset(char *s,intch,size_t n)

       将字符串s的前n个字符置于ch中

char   strpbrk(const char*s1,const char *s2)

       扫描字符串s1,并返回在s1和s2中均有的字符个数

char   strrchr(const char*s,int c)

       扫描最后出现一个给定字符c的一个字符串s

char   strrev(char *s)

       将字符串s中的字符全部颠倒顺序重新排列,并返回排列后的字符串

char   strset(char *s,intch)

       将一个字符串s中的所有字符置于一个给定的字符ch

size_t strspn(const char *s1,const char *s2)

       扫描字符串s1,并返回在s1和s2中均有的字符个数

char   strstr(const char*s1,const char *s2)

       扫描字符串s2,并返回第一次出现s1的位置

char   strtok(char *s1,constchar *s2)

       检索字符串s1,该字符串s1是由字符串s2中定义的定界符所分隔

char   strupr(char *s)

       将字符串s中的小写字母全部转换成大写字母,并返回转换后的字符串

 

存贮分配子程序,所在函数库为dos.h、alloc.h、malloc.h、stdlib.h、process.h

int   allocmem(unsigned size,unsigned *seg)利用DOS分配空闲的内存,

       size为分配内存大小,seg为分配后的内存指针

int   freemem(unsigned seg)释放先前由allocmem分配的内存,seg为指定的内存指针

int   setblock(int seg,int newsize)本函数用来修改所分配的内存长度,

       seg为已分配内存的内存指针,newsize为新的长度

 

int   brk(void *endds)

       本函数用来改变分配给调用程序的数据段的空间数量,新的空间结束地址为endds

char  *sbrk(int incr)

       本函数用来增加分配给调用程序的数据段的空间数量,增加incr个字节的空间

 

unsigned long coreleft() 本函数返回未用的存储区的长度,以字节为单位

void  *calloc(unsigned nelem,unsignedelsize)分配nelem个长度为elsize的内存空间

       并返回所分配内存的指针

void  *malloc(unsignedsize)分配size个字节的内存空间,并返回所分配内存的指针

void   free(void*ptr)释放先前所分配的内存,所要释放的内存的指针为ptr

void  *realloc(void *ptr,unsignednewsize)改变已分配内存的大小,ptr为已分配有内

       存区域的指针,newsize为新的长度,返回分配好的内存指针.

 

long   farcoreleft()本函数返回远堆中未用的存储区的长度,以字节为单位

void far *farcalloc(unsigned long units,unsigned longunitsz)

          从远堆分配units个长度为unitsz的内存空间,并返回所分配内存的指针

void  *farmalloc(unsigned longsize)分配size个字节的内存空间,

      并返回分配的内存指针

void   farfree(void far*block)释放先前从远堆分配的内存空间,

       所要释放的远堆内存的指针为block

void far *farrealloc(void far *block,unsigned longnewsize)改变已分配的远堆内

          存的大小,block为已分配有内存区域的指针,newzie为新的长度,返回分配好

          的内存指针

时间日期函数,函数库为time.h、dos.h

在时间日期函数里,主要用到的结构有以下几个:

总时间日期贮存结构tm

┌──────────────────────┐

│structtm                                  │

│{                                          │

│ int tm_sec;                   │

│ int tm_min;                   │

│ int tm_hour;                  │

│ int tm_mday;                │

│ int tm_mon;                 │

│ int tm_year;             │

│ int tm_wday;        │

│ int tm_yday;    │

│ int tm_isdst; │

│}                                          │

└──────────────────────┘

日期贮存结构date

┌───────────────┐

│structdate                  │

│{                            │

│ int da_year; │

│ char da_day;       │

│ char da_mon;   │

│}                            │

└───────────────┘

时间贮存结构time

┌────────────────┐

│structtime                    │

│{                              │

│ unsigned char ti_min;  │

│ unsigned char ti_hour; │

│ unsigned charti_hund;        │

│ unsigned char ti_sec;   │

│                               │

└────────────────┘

char     *ctime(long *clock)

           本函数把clock所指的时间(如由函数time返回的时间)转换成下列格式的

           字符串:Mon Nov 21 11:31:54 1983\n\0

char     *asctime(struct tm *tm)

           本函数把指定的tm结构类的时间转换成下列格式的字符串:

           Mon Nov 21 11:31:54 1983\n\0

double    difftime(time_t time2,time_t time1)

           计算结构time2和time1之间的时间差距(以秒为单位)

struct tm *gmtime(long *clock)本函数把clock所指的时间(如由函数time返回的时间)

           转换成格林威治时间,并以tm结构形式返回

struct tm *localtime(long*clock)本函数把clock所指的时间(如函数time返回的时间)

           转换成当地标准时间,并以tm结构形式返回

void      tzset()本函数提供了对UNIX操作系统的兼容性

long      dostounix(struct date *dateptr,struct time *timeptr)

           本函数将dateptr所指的日期,timeptr所指的时间转换成UNIX格式,并返回

           自格林威治时间1970年1月1日凌晨起到现在的秒数

void      unixtodos(long utime,struct date *dateptr,struct time *timeptr)

           本函数将自格林威治时间1970年1月1日凌晨起到现在的秒数utime转换成

           DOS格式并保存于用户所指的结构dateptr和timeptr中

void      getdate(struct date *dateblk)本函数将计算机内的日期写入结构dateblk 中以供用户使用

void      setdate(struct date *dateblk)本函数将计算机内的日期改成由结构dateblk所指定的日期

void      gettime(struct time*timep)本函数将计算机内的时间写入结构timep中, 以供用户使用

void      settime(struct time*timep)本函数将计算机内的时间改为 由结构timep所指的时间

long      time(long*tloc)本函数给出自格林威治时间1970年1月1日凌晨至现在所经 过的秒数,并将该值存于tloc所指的单元中.

int       stime(long*tp)本函数将tp所指的时间(例如由time所返回的时间) 写入计算机中.    

结束了*/

	return 0; 
}
